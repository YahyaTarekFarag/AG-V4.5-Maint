


نظام AG V4.5
نظام إدارة الصيانة والخدمات الميدانية


تقرير الفحص التقني المعمّق — الإصدار الثاني

تاريخ التقرير: فبراير 2026
React 18 + TypeScript 5 + Supabase + Vite 5


التقييم الإجمالي المُعمَّق	78/100 — جيد جداً ⭐⭐⭐⭐
جودة الكود	74/100
الأداء	76/100
المعمارية والتصميم	85/100
تجربة المستخدم (UX/UI)	88/100
قاعدة البيانات (Supabase)	81/100
 
١. التحليل المعماري العميق — نظام Sovereign
نظام Sovereign هو الابتكار الجوهري في AG V4.5. فلسفته: قاعدة البيانات تقود الواجهة، وليس العكس. هذا يجعل الإضافات والتعديلات تتم بدون كتابة كود Frontend جديد.

١.١ المكونات السبعة لنظام Sovereign

المكوّن	الملف	الوظيفة	التقييم
useSovereign	hooks/useSovereign.ts	الـ Hook الأساسي: pagination + cache + joins	92/100
SovereignTable	components/sovereign/SovereignTable.tsx	جدول ديناميكي: بحث + تصدير + استيراد Excel	82/100
SovereignKPICard	components/sovereign/SovereignKPICard.tsx	بطاقات KPI بـ RPC server-side aggregation	90/100
SovereignActionModal	components/sovereign/SovereignActionModal.tsx	نموذج ديناميكي من form_config بالكامل	85/100
SchemaBuilderPage	pages/SchemaBuilderPage.tsx	محرر schema + DB Explorer + DDL تلقائي	88/100
MasterDataPage	pages/MasterDataPage.tsx	الصفحة العامة التي تربط كل المكونات	80/100
RPC Functions	Supabase DB	sovereign_list_tables, sovereign_add_column, sovereign_get_aggregate	87/100

١.٢ تدفق البيانات — الرحلة الكاملة
عند فتح أي صفحة بيانات رئيسية، يحدث التالي بالترتيب:
•	١. MasterDataPage تقرأ المسار من URL (مثلاً /branches)
•	٢. useSovereign يُشغِّل Promise.all لثلاث عمليات متوازية: جلب schema من ui_schemas، جلب count بـ is_deleted filter، وجلب أول 50 صف مع الـ joins المناسبة
•	٣. SovereignTable يستقبل الـ schema ويبني الجدول تلقائياً بناءً على list_config.columns
•	٤. SovereignActionModal يستقبل form_config.fields ويبني النموذج ديناميكياً
•	٥. عند الحفظ، SchemaBuilderPage تُشغِّل sovereign_add_column RPC لإضافة أعمدة مفقودة في قاعدة البيانات

١.٣ نقطة قوة استثنائية: DDL بدون SQL
ميزة فريدة من نوعها
SchemaBuilderPage تتيح للمدير إضافة حقول جديدة للنموذج، ويقوم النظام تلقائياً بإضافة الأعمدة المقابلة لجدول قاعدة البيانات عبر sovereign_add_column RPC. هذا يعني إمكانية توسيع البرنامج بالكامل بدون مطور أو SQL.

١.٤ نقاط الضعف المعمارية
•	getSelectString() كـ switch-case: هذه الدالة في useSovereign.ts تحتوي على 12 case يدوية لتحديد الـ joins المناسبة لكل جدول. عند إضافة جداول عبر Schema Builder، لن يكون لها joins تلقائية — ستُرجع IDs بدلاً من أسماء. الحل الأمثل هو تخزين الـ select string في ui_schemas.list_config نفسه.
•	SovereignActionModal يُحمِّل lookups بشكل متسلسل: fetchLookups() تُشغِّل loop for-of بدلاً من Promise.all، مما يعني أن جلب 4 قوائم منسدلة يستغرق 4 round trips متسلسلة بدلاً من واحد متوازٍ.
•	إدارة الحالة غير مركزية: كل مكوّن يحمل state خاصته. لو تبنّى المشروع Zustand أو React Query، ستختفي الـ fetch المكررة بين المكونات.
 
٢. تحليل جودة الكود المعمّق
جودة TypeScript  ██████████████░░░░░░  68/100
قابلية الصيانة  ██████████████░░░░░░  72/100
إعادة الاستخدام (Reusability)  █████████████████░░░  85/100
وضوح الكود  ████████████████░░░░  78/100

٢.١ مشكلات TypeScript — تحليل تفصيلي
النظام يستخدم TypeScript لكنه يفقد كثيراً من فوائده بسبب الإفراط في استخدام any:

الملف	المشكلة	الأثر
SovereignTable.tsx	record: any في 8 أماكن	فقدان autocomplete وtype checking
SovereignActionModal.tsx	record: any | null في interface	أخطاء runtime محتملة
useSovereign.ts	(tableName as any) في 5 أماكن	تجاوز type safety لـ Supabase
TicketFlow.tsx	ticket: any في props	بلا contracts واضحة
SchemaBuilderPage.tsx	(data as any[]) في fetchDbTables	تجاهل أخطاء API
ShiftStatus.tsx	'technician_attendance' as any	الجدول غير موجود في types

الحل المُقترح: إنشاء interfaces مركزية في types/database.ts:
interface Ticket { id: string; status: 'open'|'assigned'|'in_progress'|'resolved'|'closed'; asset_name: string; branch_id: string; ... }
interface Profile { id: string; full_name: string; role: UserRole; branch_id?: string; ... }
type UserRole = 'admin'|'manager'|'technician'|'maint_manager'|'maint_supervisor'|...;

٢.٢ مشكلة الدالة المكررة في SovereignTable
تم اكتشاف دالة getCellValue مُعرَّفة مرتين في SovereignTable.tsx — هذا يشير إلى refactoring غير مكتمل:
// دالة مكررة — تُسبب confusion عند التعديل
const getCellValue = (record: any, col: ColumnConfig) => { ... }  // النسخة 1
const getCellValue = (record: any, key: string) => { ... }       // النسخة 2 مختلفة!

٢.٣ تحليل حجم الملفات

الملف	الوضع
SovereignTable.tsx (545 سطر)	يحتاج تقسيم إلى: SovereignTable + SovereignSearch + ExcelImporter
SchemaBuilderPage.tsx (623 سطر)	يحتاج تقسيم إلى: SchemaBuilder + DBExplorer + KPIEditor
MaintenanceDashboardPage.tsx (411 سطر)	يحتاج تقسيم: fetchAll بدون pagination + منطق معقد
TicketFlow.tsx (553 سطر)	يحتاج تقسيم: StartWork + ResolveForm + RateForm كمكونات منفصلة
SovereignActionModal.tsx (501 سطر)	مقبول بصعوبة — المنطق متنوع (GPS + Image + QR + Form)
useSovereign.ts (196 سطر)	جيد — حجم مناسب لـ hook بهذا التعقيد

٢.٤ معالجة الأخطاء — تحليل شامل
فحص كل ملف لمعرفة كيفية التعامل مع الأخطاء:

السيناريو	التقييم
SovereignActionModal: error.message يظهر للمستخدم مباشرة	جيد — فوري وواضح
useSovereign: fallback ذكي لـ is_deleted غير موجود	ممتاز — يتكيف مع قاعدة البيانات
TicketFlow: جلب inventory بدون معالجة خطأ	مشكلة — الفشل صامت
Dashboard.tsx: loadKPICards بدون try-catch	مشكلة — الفشل يوقف الصفحة
fetchBranchResources: لا يُعالج الأخطاء	مشكلة — القوائم تبقى فارغة صامتة
ShiftStatus: setShiftError يعرض الخطأ للمستخدم	جيد
TicketFlow: inventory_transactions insert بدون await صحيح	خطر — التحقق من النجاح غائب
 
٣. تحليل الأداء المعمّق
أداء الـ API Calls  ██████████████░░░░░░  72/100
إدارة الذاكرة  ████████████████░░░░  80/100
جودة الـ Caching  █████████████░░░░░░░  65/100
Bundle Size  ██████████████░░░░░░  70/100

٣.١ المشكلة الأبرز: fetchAll() في MaintenanceDashboardPage
مشكلة أداء حرجة
MaintenanceDashboardPage.tsx تستخدم fetchAll() التي تجلب جميع البلاغات بدون أي حد. في بيئة إنتاج مع آلاف البلاغات، هذا يعني تحميل آلاف الصفوف في الذاكرة وعرضها في جدول واحد بدون pagination.

الكود الحالي في MaintenanceDashboardPage:
const { data } = await supabase.from('tickets').select('*') // جلب الكل بدون حد!
الحل المقترح:
const { data, count } = await supabase.from('tickets').select('*', { count: 'exact' })
  .range(page * 50, page * 50 + 49) // pagination
  .order('created_at', { ascending: false })

٣.٢ مشكلة Dashboard.tsx: Client-side Count
Dashboard.tsx تجلب tickets للعد ثم تُحسبها في الـ browser:
// الكود الحالي — inefficient
const { data: allTickets } = await supabase.from('tickets').select('*')
const openCount = allTickets.filter(t => t.status === 'open').length

البديل بـ server-side counting الصحيح (أسرع 10-100x):
// الحل الصحيح — 4 queries متوازية
const [open, assigned, inProgress, resolved] = await Promise.all([
  supabase.from('tickets').select('*', {count:'exact',head:true}).eq('status','open'),
  supabase.from('tickets').select('*', {count:'exact',head:true}).eq('status','assigned'),
  supabase.from('tickets').select('*', {count:'exact',head:true}).eq('status','in_progress'),
  supabase.from('tickets').select('*', {count:'exact',head:true}).eq('status','resolved'),
])

٣.٣ fetchAllRows: خطر في الإنتاج
دالة fetchAllRows في useSovereign تجلب جميع الصفوف للتصدير بدون أي حد أقصى. مع جدول inventory_transactions يحتوي 10,000+ صف، قد تستغرق دقائق أو تفشل.
// المشكلة: بدون حد
const { data: rows } = await supabase.from(tableName).select(getSelectString())

التحسين: إضافة limit أو عرض تحذير للمستخدم إذا تجاوز العدد حداً معيناً:
if (totalCount > 5000) { alert('الجدول يحتوي +5000 صف، التصدير قد يستغرق وقتاً') }

٣.٤ فرصة: Code Splitting
البرنامج يحمّل جميع المكتبات الثقيلة عند أول تحميل. الحل: React.lazy + Suspense:
// قبل: import مباشر
import SchemaBuilderPage from './pages/SchemaBuilderPage'  // 623 سطر + xlsx

// بعد: lazy loading
const SchemaBuilderPage = React.lazy(() => import('./pages/SchemaBuilderPage'))
const MapPage = React.lazy(() => import('./pages/MapPage'))  // Leaflet ثقيل

٣.٥ تحليل Real-time Subscriptions
البرنامج يستخدم Supabase Realtime بشكل محدود وصحيح:
الصفحة	التقييم
MapPage: postgres_changes على technician_attendance	ممتاز — realtime للخريطة الحية
Dashboard.tsx: subscription لتحديث تلقائي	جيد
MaintenanceDashboardPage: بدون realtime	فرصة تحسين — إضافة subscription للبلاغات الجديدة
TicketFlow: بدون realtime	مقبول — المستخدم يُحدِّث يدوياً
 
٤. تحليل الميزات الوظيفية — عمق كامل

٤.١ نظام TicketFlow — دورة حياة البلاغ الكاملة
TicketFlow.tsx هو قلب النظام التشغيلي. يُطبِّق workflow احترافي من 5 مراحل:

المرحلة	الحالة	الفاعل	البيانات المُسجَّلة
١	open (فتح البلاغ)	Manager	GPS + صورة العطل + الفرع + المعدة + category
٢	assigned (تعيين فني)	Maint Manager/Supervisor	assigned_to_profile_id → status=assigned
٣	in_progress (بدء العمل)	Technician/Supervisor	GPS تحقق من الفرع + started_at + mission log تلقائي
٤	resolved (إتمام الإصلاح)	Technician/Supervisor	GPS + صورة الإصلاح + قطع غيار + category + downtime
٥	closed (اعتماد واغلاق)	Manager/Maint Manager	تقييم 5 نجوم + تعليق إلزامي

ملاحظة هامة حول TicketFlow
دالة handleAction للحالة 'resolve' تُرسل inventory_transactions بدون await صحيح للحلقة — لو فشل إدخال قطعة ما، لن يتوقف الكود ويستمر في تحديث حالة البلاغ. هذا يعني إمكانية خروج رصيد المخزون عن التزامن.

٤.٢ نظام الحضور والمأموريات
ShiftStatus.tsx يُطبِّق نظاماً احترافياً لتسجيل الحضور:
•	GPS إلزامي عند بدء وإنهاء المناوبة
•	عداد حي (live timer) يظهر مدة المناوبة الحالية بتنسيق HH:MM
•	Real-time تلقائي عبر Supabase Realtime في MapPage
•	الحالة مرئية في الخريطة التشغيلية فوراً

لكن هناك نقطة ضعف:
مشكلة: لا يوجد منع لنسيان إنهاء المناوبة
لو نسي الفني الضغط على 'إنهاء المناوبة'، ستبقى مناوبته مفتوحة إلى الأبد ويظهر في الخريطة متاحاً. التحسين: إضافة auto-close بعد X ساعات أو إشعار تذكيري.

٤.٣ نظام الرواتب والمحفظة الرقمية
TechnicianSalaryPage.tsx يعرض:
•	إجمالي مستحقات اليوم (net_earning) من جدول payroll_logs
•	تفكيك المبلغ: بدل انتقال + مكافأة نجوم
•	سجل آخر 7 أيام مع حالة (تم صرف / مستحق)
•	تحذير بأن الحسابات تتم server-side عبر trigger عند إغلاق البلاغات

ملاحظة: payroll_logs كـ (as any) — يعني جدول الرواتب غير مسجَّل في TypeScript types. الحسابات تعتمد على DB triggers (log_technician_mission RPC).

٤.٤ نظام QR Scanner
يظهر QR Scanner في موضعين:
الموضع	الاستخدام
SovereignActionModal: حقول بخاصية scanable:true	مسح أي حقل نصي (رقم تسلسلي، بطاقة موظف، إلخ)
TicketFlow: زر QR بجانب قائمة المعدات	مطابقة الأصل برقم تسلسلي أو asset ID تلقائياً

تقييم QR Scanner: الفكرة ممتازة وتربط العالم المادي (QR labels على المعدات) بالرقمي. لكن لا يوجد fallback إذا لم يدعم الجهاز الكاميرا.

٤.٥ نظام رفع الصور
drive.ts يستخدم Supabase Storage (بكت 'media') كبديل مؤقت لـ Google Drive. هذا واضح من التعليق في الكود 'Supabase Storage كبديل مؤقت'. التدفق:
•	الصورة الأصلية → compressImage() (max 500KB, max 1280px) → Supabase Storage → URL علني
•	image compression يعمل في Web Worker (useWebWorker: true) — لا يُجمّد الواجهة
•	مشكلة: Bucket 'media' يجب إنشاؤه يدوياً في Supabase مع public access، غير موثق
 
٥. تحليل قاعدة البيانات — Supabase
تصميم Schema  █████████████████░░░  83/100
استخدام RPC Functions  ██████████████████░░  88/100
Pagination وأداء الـ Queries  ███████████████░░░░░  75/100
Real-time  █████████████████░░░  85/100

٥.١ الجداول الرئيسية — الخريطة الكاملة

الجدول	الوظيفة	ملاحظة
profiles	بيانات الموظفين + الأدوار + الارتباطات الهرمية	FK لـ branches, areas, sectors, brands
tickets	البلاغات الكاملة — قلب النظام	7 حالات + GPS + صور + تقييمات
branches	الفروع مع إحداثيات GPS	يُستخدم للـ Geofencing
maintenance_assets	سجل الأصول والمعدات	مرتبط بـ branches + categories
maintenance_categories	تصنيفات الأعطال الفنية	مُستخدم في TicketFlow
inventory	المخزون وقطع الغيار	مرتبط بـ brands
inventory_transactions	سجل صرف القطع	مرتبط بـ tickets + technician
technician_attendance	سجل الحضور مع GPS	clock_in/clock_out + إحداثيات
technician_missions	سجل المأموريات بين الفروع	تُحسب تلقائياً بـ log_technician_mission
payroll_logs	سجل الرواتب اليومية	يتحدث بـ trigger عند إغلاق البلاغات
system_settings	إعدادات النظام (key-value)	geofencing, restrict_branch, إلخ
ui_schemas	تعريفات الواجهات — قلب نظام Sovereign	form_config + list_config + page_config

٥.٢ RPC Functions — المحرك الخفي
البرنامج يعتمد على 6 RPC functions رئيسية تُنفَّذ server-side:
الدالة	الوظيفة
sovereign_get_aggregate	حساب KPIs: count/sum/avg مع فلترة — يُجنِّب جلب آلاف الصفوف
sovereign_list_tables	قائمة جداول قاعدة البيانات مع عدد الصفوف — لـ DB Explorer
sovereign_add_column	إضافة عمود جديد لجدول موجود — DDL ديناميكي
sovereign_drop_column	حذف عمود مع بياناته — DDL ديناميكي
sovereign_create_table	إنشاء جدول جديد بـ id/created_at/updated_at تلقائياً
log_technician_mission	تسجيل مأمورية تلقائي عند بدء الفني العمل — تُحسب المسافة

٥.٣ نقاط ضعف في الـ Queries
•	مشكلة fetchLookups في SovereignActionModal: تُشغِّل queries متسلسلة في for-of loop. لو كان النموذج يحتوي 4 حقول select، هذا 4 round trips متسلسلة. الحل: Promise.all.
// حالي — بطيء
for (const field of lookupFields) { const {data} = await supabase.from(field.dataSource)... }
// أفضل
await Promise.all(lookupFields.map(f => supabase.from(f.dataSource).select('*')))

•	fetchBranchResources في ManagerTicketsPage: تجلب جميع assets للفرع و categories بدون حد. مع فرع يحتوي 200+ معدة، قد يكون بطيئاً. تحسين: .select('id, name, model_number') بدلاً من select('*').
•	MapPage — جلب technician_attendance: تجلب جميع المناوبات المفتوحة مع profiles join. مع بيئة كبيرة جداً قد يكون ثقيلاً، لكن عادياً مقبول لأن المناوبات المفتوحة في وقت واحد محدودة.
 
٦. تحليل تجربة المستخدم (UX/UI) المعمّق
جودة التصميم البصري  ██████████████████░░  90/100
Responsive Design  ██████████████████░░  88/100
تجربة Mobile  █████████████████░░░  85/100
معالجة حالات التحميل  ████████████████░░░░  82/100
Offline Support  ███████████░░░░░░░░░  55/100

٦.١ نقاط UX الاستثنائية
•	Bottom Sheet للموبايل: SovereignActionModal وTicketFlow يكتشفان حجم الشاشة ويعرضان bottom sheet بدلاً من modal عند العرض الضيق. هذا تحسين UX احترافي يُريح الفنيين الذين يعملون بالهاتف.
•	Network Status Badge: DashboardLayout يتابع حالة الاتصال لحظياً ويعرض Badge خضراء/حمراء مع نبضة حية. الفنيون في المواقع الضعيفة يرون حالة الاتصال فوراً.
•	PWA Install Banner: Sidebar تعرض زر 'تثبيت التطبيق' ذكياً فقط عند توفر beforeinstallprompt ولم يُثبَّت بعد.
•	Live Shift Timer: ShiftStatus يعرض مدة المناوبة الحالية بتنسيق HH:MM يتحدث كل ثانية — رائع لتتبع الوقت الفعلي.
•	GPS Success Feedback: SovereignActionModal يعرض '✅ تم التقاط الإحداثيات بنجاح!' لـ 3 ثوانٍ ثم يختفي تلقائياً.
•	Geofencing Error Messages: رسائل الخطأ للـ geofencing تُظهر المسافة الحالية للمستخدم: 'المسافة الحالية: 450 متر' — بدلاً من رسالة عامة.

٦.٢ فرص تحسين UX
•	لا يوجد Skeleton Loading: جميع الصفحات تعرض spinner أثناء التحميل. Skeleton screens ستبدو أكثر احترافية وتقلل من الشعور بالانتظار.
•	لا يوجد Optimistic UI: عند إغلاق بلاغ، يجب انتظار API قبل تحديث الواجهة. Optimistic update سيجعل التجربة فورية.
•	لا يوجد Search في القوائم الجانبية الطويلة: Sidebar تعرض حتى 20 رابط — في الشاشات الصغيرة يصعب التنقل.
•	Offline Support محدود: PWA مفعّل لكن لا يوجد Service Worker حقيقي لـ cache الـ API calls. عند انقطاع الاتصال، كل العمليات تفشل.
•	لا يوجد Undo بعد الحذف: الحذف الناعم (soft delete) موجود لكن لا توجد واجهة لاسترجاع المحذوفات.
 
٧. خارطة التحسينات — 3 مراحل

المرحلة الأولى: تحسينات عاجلة (أسبوع)

#	المشكلة	الحل	الملف المتأثر
1	inventory_transactions insert بدون await/error handling	إضافة await + try-catch لكل insert في الحلقة	TicketFlow.tsx
2	fetchLookups بحلقة متسلسلة	تحويل لـ Promise.all	SovereignActionModal.tsx
3	Dashboard يجلب all tickets للعد	استبدال بـ 4 count queries متوازية	Dashboard.tsx
4	دالة getCellValue مكررة	حذف النسخة الثانية ودمج المنطق	SovereignTable.tsx
5	loadKPICards بدون try-catch	إضافة error boundary	Dashboard.tsx

المرحلة الثانية: تحسينات مهمة (شهر)
•	إضافة pagination لـ MaintenanceDashboardPage: يحتاج تعديل fetchAll() لاستخدام range() + count مع عرض أزرار الصفحات كما في useSovereign.
•	إضافة Types محددة لأهم الجداول: إنشاء types/database.ts يحتوي على Ticket، Profile، InventoryItem، Branch interfaces.
•	تقسيم الملفات الكبيرة: SovereignTable → 3 ملفات، SchemaBuilderPage → 3 ملفات، TicketFlow → 3 ملفات.
•	إضافة limit للـ fetchAllRows: عرض warning للمستخدم إذا تجاوز عدد الصفوف 5000 قبل التصدير.
•	نقل getSelectString لـ ui_schemas: بدلاً من switch-case، تخزين selectQuery في قاعدة البيانات نفسها وجعله قابلاً للتخصيص.
•	إضافة auto-close للمناوبات المفتوحة: DB trigger أو cron job يُغلق المناوبات التي تجاوزت 16 ساعة.

المرحلة الثالثة: تحسينات متقدمة (ربع سنوي)
•	React.lazy للصفحات الثقيلة: MapPage (Leaflet)، SchemaBuilderPage (xlsx)، يُقلل Initial Bundle Size.
•	Skeleton Loading بدلاً من spinners: تحسين بصري ملحوظ لتجربة المستخدم.
•	Offline Queue: تخزين العمليات في IndexedDB عند انقطاع الاتصال وإعادة إرسالها عند العودة.
•	React Query أو Zustand: إدارة state مركزية تُلغي الـ fetch المكررة بين المكونات.
•	Unit Tests للـ hooks: useSovereign على الأقل يحتاج unit tests لأنه جوهر النظام.
•	استكمال Google Drive Integration: drive.ts يُشير لـ Google Drive لكن يستخدم Supabase Storage كبديل. إكمال التكامل الفعلي إذا كان مطلوباً.
 
٨. الخلاصة والتقييم النهائي

تقييم شامل — AG V4.5
نظام AG V4.5 يُمثِّل برنامجاً ناضجاً ومتكاملاً بمفهوم معماري فريد (Sovereign System). الكود مكتوب بوعي هندسي واضح، وعدد من الأفكار لا نراها في كثير من المشاريع التجارية. الفجوات الموجودة طبيعية في مشاريع في طور التطوير وقابلة للحل بشكل تدريجي.

أبرز ما يميز هذا النظام
•	نظام Sovereign الديناميكي: فكرة نادرة ومُنفَّذة بجودة — قاعدة البيانات تقود الواجهة بالكامل.
•	DDL ديناميكي بدون SQL: إضافة جداول وحقول عبر UI — ميزة enterprise نادرة في مشاريع مشابهة.
•	دورة حياة البلاغ الكاملة: 5 مراحل مع GPS + صور + مخزون + تقييم — تغطية شاملة لعمليات الصيانة.
•	Real-time والخريطة الحية: مراقبة الفنيين على الخريطة لحظياً مع Leaflet + Supabase Realtime.
•	نظام رواتب مرتبط: ربط المأموريات بالرواتب تلقائياً عبر DB triggers — نادر في مشاريع مشابهة.

أهم 5 تحسينات بالأولوية
1.	إصلاح inventory_transactions insert في TicketFlow (خطر بيانات)
2.	تحسين Dashboard.tsx: count queries بدلاً من جلب كل البيانات (أداء)
3.	إضافة pagination لـ MaintenanceDashboardPage (أداء)
4.	تحويل fetchLookups إلى Promise.all (أداء)
5.	إنشاء types/database.ts بـ interfaces محددة (جودة كود)

